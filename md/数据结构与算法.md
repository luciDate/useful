# 数据结构与算法

数据是是计算机的基础 算法是计算机的科学

[栈](#tip-1)

[队列](#tip-2)

[链表](#tip-3)

---

## <a id="tip-1">栈</a>

栈的实现非常类似数组，是一种先进后出的数据结构

![image text](./images/test-1.png)

[1,2,3,4,5,6]

1 作为栈底
6 作为栈顶
数组的 push (进栈)和 pop (出栈)操作都是在栈顶操作的

栈的数组实现

```javascript
class Stack {
  constructor() {
    this.arr = [1, 2, 3];
  }
  //入栈
  azPush(item) {
    this.arr.push(item);
  }
  //出栈
  azPop() {
    return this.arr.pop();
  }
  //查看栈头
  peek() {
    return arr[this.arr.length - 1];
  }
  //检查栈
  getarr() {
    return this.arr;
  }
  //检查栈是否为空
  isEmpty() {
    return this.arr.length == 0;
  }
  //清空栈
  clear() {
    return (this.arr = []);
  }
  //获取栈大小
  size() {
    return this.arr.length;
  }
}
```

十进制转二进制

![image text](./images/test-2.png)

```javascript
function getTwo(number) {
  const arr = [];
  let yushu = null;
  let str = "";

  while (number > 0) {
    yushu = number % 2;
    arr.push(yushu);
    number = Math.floor(number / 2);
  }

  while (arr.length > 0) {
    str += arr.pop();
  }

  return str;
}
```

函数栈顺序

![image text](./images/test-3.png)

```javascript
function fooi() {
  return console.log("foo i finish");
}

function fooii() {
  fooi();
  return console.log("foo ii finish");
}

//先调用先入栈
fooii();
```

## <a id="tip-2">队列</a>

栈的实现非常类似数组，是一种先进先出的数据结构

![image text](./images/test-4.png)

```javascript
class Queue {
  constructor() {
    this.arr = [];
  }
  //入队
  enqueue(item) {
    arr.push();
  }
  //出队
  dequeue() {
    return this.arr.shift();
  }
  //查看队头
  fornt() {
    return this.arr[0];
  }
  //查看队是否为空
  isEmpty() {
    return this.arr.length == 0;
  }
  //队大小
  size() {
    return this.arr.length;
  }
}
```

丢手绢游戏实现队列

```javascript
function go(number) {
  const names = ["a", "b", "c", "d", "e", "f"];
  let total = null;
  while (names.length > 1) {
    for (let i = 0; i < number - 1; i++) {
      names.push(names.shift());
    }
    //踢走中手绢的人
    total = names.shift();
    console.log("淘汰的玩家是 -" + total);
  }
  return names.shift();
}

console.log(go(3));
```

数组实现队列优先级

```javascript
const list = [
  { id: 1, priority: 6 },
  { id: 2, priority: 5 },
  { id: 3, priority: 3 },
];

function priority(item) {
  flag = false;

  for (let index = 0; index < list.length; index++) {
    if (item.priority > list[index].priority) {
      list.splice(index, 0, item);
      flag = true;
      break;
    }
  }

  if (!flag) list.push(item);
}

priority({ id: 4, priority: 5 });

console.log(list);
```

## <a id="tip-3">链表</a>

![image text](./images/test-5.png)

类实现链表尾添加元素

```javascript
class Chain {
  constructor() {
    this.head = null;
    this.length = 0;
  }
  append(element) {
    const node = new Node(element);
    if (this.head == null) {
      //第一轮
      this.head = node;
    } else {
      let current = this.head;
      //第三轮
      while (current.next) {
        current = current.next;
      }
      //第二轮
      current.next = node;
    }
    this.length++;
  }
  insert(position, element) {
    //插入范围,第一个node位置为0，所以不能大于length
    if (position > -1 && position < this.length) {
      const node = new Node(element);
      if (position == 0) {
        let current = this.head;
        this.head = node;
        //插入的效果与splice一样
        this.head.next = current;
      } else {
        let index = 0;
        let current = this.head;
        let previous = null;
        //循环弄node对象，确保index小于positon 1
        while (index < position) {
          previous = current;
          current = current.next;
          index++;
        }
        //通过循环重新赋值，保存位置
        previous.next = node;
        node.next = current;
      }
      this.length++;
    }
  }
  removeAt(position) {
    if (position > -1 && position < this.length) {
      let current = null;
      if (position == 0) {
        current = this.head;
        //通过对象的重新赋值达到删除的效果
        this.head = current.next;
      } else {
        current = this.head;
        let previous = null;
        let index = 0;
        while (index < position) {
          previous = current;
          current = current.next;
          index++;
        }
        previous.next = current.next;
      }
      this.length--;
      return current;
    }
  }
  indexOf(element) {
    let current = this.head;
    let index = 0;
    while (current) {
      if (current.element === element) {
        return index;
      }
      current = current.next;
      index++;
    }
    return -1;
  }
  remove(element) {
    //传参需要的是值不是下标
    return this.removeAt(this.indexOf(element));
  }
  isEmpty() {
    return this.length == 0;
  }
  size() {
    return this.length;
  }
  getHead() {
    return this.head;
  }
}

class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

const c = new Chain();
c.append(1);
c.append(2);
c.append(3);

c.insert(1, 10);

c.remove(1);

//c.removeAt(0)

//console.log(c.indexOf(10))

console.log(c.getHead());
```

